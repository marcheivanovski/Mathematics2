#model  <- glm(y ~ X2+X3+X4+X5+X6+X7+X8+X9+X10+X11, family="binomial", data=df)
#y_pred <- predict(model, df[,2:11], type="response")
y_pred <- as.matrix(df[,1:11]) %*% x
return (prod(lr_likelihood(df$y, y_pred)))
}
p_scenario_test <- function(x){
return (0.1)
}
calculate_M(p_scenario3, envelope_multi_norm, envelope_multi_norm_sampler, n) + 0.5
samples <- rejection_sampling(p_scenario3, envelope_multi_norm, envelope_multi_norm_sampler, M, 1000, n)
calculate_M(p_scenario3, envelope_uniform, envelope_uniform_sampler, n)
M <- 5.232946e-214
M
samples <- rejection_sampling(p_scenario3, envelope_uniform, envelope_uniform_sampler, M, 1000, n)
rnorm(2,0,1)
t(rnorm(2,0,1))
p_scenario2 <- function(x) {
B <- 0.05
(-(x[1]^2)/200- 0.5 * (x[2]+ B * x[1]^2 - 100*B)^2 )
}
calculate_M(p_scenario2, envelope_multi_norm, envelope_multi_norm_sampler, n)
n <- 2
## Uniform envelope
M <- calculate_M(p_scenario2, envelope_uniform, envelope_uniform_sampler, n) + 0.5 #0.5 added just to be on the safe side
samples <- rejection_sampling(p_scenario2, envelope_uniform, envelope_uniform_sampler, M, 1000, n)
## Bivariate normal envelope
#M <- calculate_M(p_scenario2, envelope_multi_norm, envelope_multi_norm_sampler, n) + 0.5
#samples <- rejection_sampling(p_scenario2, envelope_multi_norm, envelope_multi_norm_sampler, M, 1000, n)
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
M <- calculate_M(p_scenario2, envelope_uniform, envelope_uniform_sampler, n)
M <- calculate_M(p_scenario2, envelope_uniform, envelope_uniform_sampler, n)
M
## Bivariate normal envelope
M <- calculate_M(p_scenario2, envelope_multi_norm, envelope_multi_norm_sampler, n)
M
samples <- matrix(vector('numeric', length=10000*n), ncol=n)
samples
for (i in 1:10000){
samples[i,]<-g_sampler(n)
}
samples
apply(samples, 1, p_scenario2)
max(apply(samples, 1, p_scenario2))
p_scenario2 <- function(x) {
B <- 0.05
-(-(x[1]^2)/200- 0.5 * (x[2]+ B * x[1]^2 - 100*B)^2 )
}
max(apply(samples, 1, p_scenario2))
p_scenario2 <- function(x) {
B <- 0.05
exp( (-(x[1]^2)/200- 0.5 * (x[2]+ B * x[1]^2 - 100*B)^2 ) )
}
max(apply(samples, 1, p_scenario2))
min(apply(samples, 1, p_scenario2))
p_scenario2 <- function(x) {
B <- 0.05
exp( (-(x[1]^2)/200- 0.5 * (x[2]+ B * x[1]^2 - 100*B)^2 ) )
}
## Bivariate normal envelope
M <- calculate_M(p_scenario2, envelope_multi_norm, envelope_multi_norm_sampler, n)
M
samples <- rejection_sampling(p_scenario2, envelope_multi_norm, envelope_multi_norm_sampler, M, 1000, n)
envelope_multi_norm <- function(x){
mu <- rep(0, length(x))
sigma <- diag(nrow=length(x))
return (dmvnorm(x, mu, sigma))
}
envelope_multi_norm_sampler <- function(n){
g_mu <- rep(0, n)
g_sigma <- diag(nrow=n)
return (c(rmvnorm(1, g_mu, g_sigma)))
}
envelope_uniform <- function(x){
return (1)
}
envelope_uniform_sampler <- function(n){
return (c(runif(n, -5, 5)))
}
calculate_M <- function(f, g, g_sampler, n){
samples <- matrix(vector('numeric', length=10000*n), ncol=n)
for (i in 1:10000){
samples[i,]<-g_sampler(n)
}
g_values <- apply(samples, 1, g)
f_values <- apply(samples, 1, f)
M <- max(f_values/g_values, na.rm = T)
return (M)
}
rejection_sampling <- function (f, g, g_sampler, M, m, n){
samples <- matrix(vector('integer', 2*m), ncol = 2)
for(i in 1:m){
print("On sample", i)
repeat{
y <- g_sampler(n) #2 is the dimension of bivariate
u <- runif(1)
#print(u)
#print((f(y)/(M*g(y))))
#print("----")
if ( u <= (f(y)/(M*g(y))) ){
break
}
else{
#print("nope")
}
}
samples[i,] <- y
}
return (samples)
}
#samples <- rejection_sampling(p_scenario1, envelope_multi_norm, envelope_multi_norm_sampler, 5, 10000)
M
samples <- rejection_sampling(p_scenario2, envelope_multi_norm, envelope_multi_norm_sampler, M, 1000, n)
i <- 1
print("On sample", i)
print("On sample" + i)
paste("On sample" + i)
paste("On sample", i)
envelope_multi_norm <- function(x){
mu <- rep(0, length(x))
sigma <- diag(nrow=length(x))
return (dmvnorm(x, mu, sigma))
}
envelope_multi_norm_sampler <- function(n){
g_mu <- rep(0, n)
g_sigma <- diag(nrow=n)
return (c(rmvnorm(1, g_mu, g_sigma)))
}
envelope_uniform <- function(x){
return (1)
}
envelope_uniform_sampler <- function(n){
return (c(runif(n, -5, 5)))
}
calculate_M <- function(f, g, g_sampler, n){
samples <- matrix(vector('numeric', length=10000*n), ncol=n)
for (i in 1:10000){
samples[i,]<-g_sampler(n)
}
g_values <- apply(samples, 1, g)
f_values <- apply(samples, 1, f)
M <- max(f_values/g_values, na.rm = T)
return (M)
}
rejection_sampling <- function (f, g, g_sampler, M, m, n){
samples <- matrix(vector('integer', 2*m), ncol = 2)
for(i in 1:m){
paste("On sample", i)
repeat{
y <- g_sampler(n) #2 is the dimension of bivariate
u <- runif(1)
#print(u)
#print((f(y)/(M*g(y))))
#print("----")
if ( u <= (f(y)/(M*g(y))) ){
break
}
else{
#print("nope")
}
}
samples[i,] <- y
}
return (samples)
}
#samples <- rejection_sampling(p_scenario1, envelope_multi_norm, envelope_multi_norm_sampler, 5, 10000)
envelope_multi_norm <- function(x){
mu <- rep(0, length(x))
sigma <- diag(nrow=length(x))
return (dmvnorm(x, mu, sigma))
}
envelope_multi_norm_sampler <- function(n){
g_mu <- rep(0, n)
g_sigma <- diag(nrow=n)
return (c(rmvnorm(1, g_mu, g_sigma)))
}
envelope_uniform <- function(x){
return (1)
}
envelope_uniform_sampler <- function(n){
return (c(runif(n, -5, 5)))
}
calculate_M <- function(f, g, g_sampler, n){
samples <- matrix(vector('numeric', length=10000*n), ncol=n)
for (i in 1:10000){
samples[i,]<-g_sampler(n)
}
g_values <- apply(samples, 1, g)
f_values <- apply(samples, 1, f)
M <- max(f_values/g_values, na.rm = T)
return (M)
}
rejection_sampling <- function (f, g, g_sampler, M, m, n){
samples <- matrix(vector('integer', 2*m), ncol = 2)
for(i in 1:m){
paste("On sample", i)
repeat{
y <- g_sampler(n) #2 is the dimension of bivariate
u <- runif(1)
#print(u)
#print((f(y)/(M*g(y))))
#print("----")
if ( u <= (f(y)/(M*g(y))) ){
break
}
else{
#print("nope")
}
}
samples[i,] <- y
}
return (samples)
}
#samples <- rejection_sampling(p_scenario1, envelope_multi_norm, envelope_multi_norm_sampler, 5, 10000)
samples <- rejection_sampling(p_scenario2, envelope_multi_norm, envelope_multi_norm_sampler, M, 100, n)
envelope_multi_norm <- function(x){
mu <- rep(0, length(x))
sigma <- diag(nrow=length(x))
return (dmvnorm(x, mu, sigma))
}
envelope_multi_norm_sampler <- function(n){
g_mu <- rep(0, n)
g_sigma <- diag(nrow=n)
return (c(rmvnorm(1, g_mu, g_sigma)))
}
envelope_uniform <- function(x){
return (1)
}
envelope_uniform_sampler <- function(n){
return (c(runif(n, -5, 5)))
}
calculate_M <- function(f, g, g_sampler, n){
samples <- matrix(vector('numeric', length=10000*n), ncol=n)
for (i in 1:10000){
samples[i,]<-g_sampler(n)
}
g_values <- apply(samples, 1, g)
f_values <- apply(samples, 1, f)
M <- max(f_values/g_values, na.rm = T)
return (M)
}
rejection_sampling <- function (f, g, g_sampler, M, m, n){
samples <- matrix(vector('integer', 2*m), ncol = 2)
for(i in 1:m){
paste("On sample", i)
repeat{
y <- g_sampler(n) #2 is the dimension of bivariate
u <- runif(1)
#print(u)
#print((f(y)/(M*g(y))))
#print("----")
if ( u <= (f(y)/(M*g(y))) ){
break
}
else{
#print("nope")
}
}
samples[i,] <- y
}
return (samples)
}
#samples <- rejection_sampling(p_scenario1, envelope_multi_norm, envelope_multi_norm_sampler, 5, 10000)
envelope_multi_norm <- function(x){
mu <- rep(0, length(x))
sigma <- diag(nrow=length(x))
return (dmvnorm(x, mu, sigma))
}
envelope_multi_norm_sampler <- function(n){
g_mu <- rep(0, n)
g_sigma <- diag(nrow=n)
return (c(rmvnorm(1, g_mu, g_sigma)))
}
envelope_uniform <- function(x){
return (1)
}
envelope_uniform_sampler <- function(n){
return (c(runif(n, -5, 5)))
}
calculate_M <- function(f, g, g_sampler, n){
samples <- matrix(vector('numeric', length=10000*n), ncol=n)
for (i in 1:10000){
samples[i,]<-g_sampler(n)
}
g_values <- apply(samples, 1, g)
f_values <- apply(samples, 1, f)
M <- max(f_values/g_values, na.rm = T)
return (M)
}
rejection_sampling <- function (f, g, g_sampler, M, m, n){
samples <- matrix(vector('integer', 2*m), ncol = 2)
for(i in 1:m){
print(paste("On sample", i))
repeat{
y <- g_sampler(n) #2 is the dimension of bivariate
u <- runif(1)
#print(u)
#print((f(y)/(M*g(y))))
#print("----")
if ( u <= (f(y)/(M*g(y))) ){
break
}
else{
#print("nope")
}
}
samples[i,] <- y
}
return (samples)
}
#samples <- rejection_sampling(p_scenario1, envelope_multi_norm, envelope_multi_norm_sampler, 5, 10000)
samples <- rejection_sampling(p_scenario2, envelope_multi_norm, envelope_multi_norm_sampler, M, 100, n)
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
## Uniform envelope
M <- calculate_M(p_scenario2, envelope_uniform, envelope_uniform_sampler, n)
M
samples <- rejection_sampling(p_scenario2, envelope_uniform, envelope_uniform_sampler, M, 1000, n)
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
## Uniform envelope
#M <- calculate_M(p_scenario3, envelope_uniform, envelope_uniform_sampler, n)
M <- 5.232946e-214
samples <- rejection_sampling(p_scenario3, envelope_uniform, envelope_uniform_sampler, M, 100, n)
samples <- rejection_sampling(p_scenario3, envelope_uniform, envelope_uniform_sampler, M, 10, n) #superrrrrrrr slow
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
## Bivariate normal envelope
M <- calculate_M(p_scenario3, envelope_multi_norm, envelope_multi_norm_sampler, n)
M
## Bivariate normal envelope
#M <- calculate_M(p_scenario3, envelope_multi_norm, envelope_multi_norm_sampler, n)
M <- 1.147597e-212
samples <- rejection_sampling(p_scenario3, envelope_multi_norm, envelope_multi_norm_sampler, M, 100, n)
samples <- rejection_sampling(p_scenario3, envelope_multi_norm, envelope_multi_norm_sampler, M, 10, n)
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
diag(1)
diag(2)
#samples <- rejection_sampling(p_scenario1, envelope_uniform, envelope_uniform_sampler, M, 1000, n)
samples <- metropolis_hastings(p_scenario1, 1000, c(0.2, 0.5), diag(2), 2)
metropolis_hastings <- function(f, m, x0, cov, dimensions){ #(x, alpha, beta, delta)
#x_new <- rnorm(1, x, cov)
#if (x_new < 0) return (x)
#p <- exp(
#  dgamma(x_new, alpha, beta, log = T) -
#    dgamma(x, alpha, beta, log = T))
#if (runif(1) > p)
#{
#  x_new <- x # reject
#}
#x_new
#New code
samples <- samples <- matrix(vector('integer', 2*m), ncol = dimensions)
samples[1,] <- x0
for(i in 2:m){
prev_x <-  samples[i-1,]
new_x <- rmvnorm(1, prev_x, cov)
alpha <- min(1, (f(new_x)*dmvnorm(new_x, prev_x, cov))/(f(prev_x)*dmvnorm(prev_x, new_x, cov)) )
u <- runif(1)
if (u<=alpha){
samples[i,]<-new_x
}
else{
samples[i,]<-prev_x
}
}
return (samples)
}
#samples <- rejection_sampling(p_scenario1, envelope_uniform, envelope_uniform_sampler, M, 1000, n)
samples <- metropolis_hastings(p_scenario1, 1000, c(0.2, 0.5), diag(2), 2)
#samples <- rejection_sampling(p_scenario1, envelope_uniform, envelope_uniform_sampler, M, 1000, n)
samples <- metropolis_hastings(p_scenario1, 1000, c(0.2, 0.5), diag(2), 2)
samples
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
n <- 2
#samples <- rejection_sampling(p_scenario1, envelope_uniform, envelope_uniform_sampler, M, 1000, n)
samples <- metropolis_hastings(p_scenario1, 10000, c(0.2, 0.5), diag(2), 2)
## Bivariate normal envelope
M <- calculate_M(p_scenario1, envelope_multi_norm, envelope_multi_norm_sampler, n) + 0.5
samples <- rejection_sampling(p_scenario1, envelope_multi_norm, envelope_multi_norm_sampler, M, 1000, n)
#samples <- rejection_sampling(p_scenario1, envelope_uniform, envelope_uniform_sampler, M, 1000, n)
samples <- metropolis_hastings(p_scenario1, 10000, c(0.2, 0.5), diag(2), 2)
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
n <- 2
samples <- metropolis_hastings(p_scenario2, 10000, c(0.2, 0.5), diag(2), 2)
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
n <- 2
samples <- metropolis_hastings(p_scenario2, 10000, c(0.2, 0.5), diag(2), 2)
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
n <- 2
samples <- metropolis_hastings(p_scenario3, 10000, c(0.2, 0.5), diag(2), 2)
df <- read.csv("datset.csv", header = TRUE, sep = ",")
metropolis_hastings <- function(f, m, x0, cov, dimensions){ #(x, alpha, beta, delta)
#New code
samples <- samples <- matrix(vector('integer', 2*m), ncol = dimensions)
samples[1,] <- x0
for(i in 2:m){
prev_x <-  samples[i-1,]
new_x <- rmvnorm(1, prev_x, cov)
print(new_x)
alpha <- min(1, (f(new_x)*dmvnorm(new_x, prev_x, cov))/(f(prev_x)*dmvnorm(prev_x, new_x, cov)) )
u <- runif(1)
if (u<=alpha){
samples[i,]<-new_x
}
else{
samples[i,]<-prev_x
}
}
return (samples)
}
n <- 2
samples <- metropolis_hastings(p_scenario3, 10000, c(0.2, 0.5), diag(2), 2)
metropolis_hastings <- function(f, m, x0, cov, dimensions){ #(x, alpha, beta, delta)
#New code
samples <- samples <- matrix(vector('integer', 2*m), ncol = dimensions)
samples[1,] <- x0
for(i in 2:m){
prev_x <-  samples[i-1,]
new_x <- rmvnorm(1, prev_x, cov)
alpha <- min(1, (f(t(new_x))*dmvnorm(new_x, prev_x, cov))/(f(t(prev_x))*dmvnorm(prev_x, new_x, cov)) )
u <- runif(1)
if (u<=alpha){
samples[i,]<-new_x
}
else{
samples[i,]<-prev_x
}
}
return (samples)
}
n <- 2
samples <- metropolis_hastings(p_scenario3, 10000, c(0.2, 0.5), diag(2), 2)
metropolis_hastings <- function(f, m, x0, cov, dimensions){ #(x, alpha, beta, delta)
#New code
samples <- samples <- matrix(vector('integer', 2*m), ncol = dimensions)
samples[1,] <- x0
for(i in 2:m){
prev_x <-  samples[i-1,]
new_x <- rmvnorm(1, prev_x, cov)
print(t(prev_x))
alpha <- min(1, (f(t(new_x))*dmvnorm(new_x, prev_x, cov))/(f(t(prev_x))*dmvnorm(prev_x, new_x, cov)) )
u <- runif(1)
if (u<=alpha){
samples[i,]<-new_x
}
else{
samples[i,]<-prev_x
}
}
return (samples)
}
n <- 2
samples <- metropolis_hastings(p_scenario3, 10000, c(0.2, 0.5), diag(2), 2)
matrix(c(1,2), nrow=1)
t(matrix(c(1,2), nrow=1))
c(matrix(c(1,2), nrow=1))
metropolis_hastings <- function(f, m, x0, cov, dimensions){ #(x, alpha, beta, delta)
#New code
samples <- samples <- matrix(vector('integer', 2*m), ncol = dimensions)
samples[1,] <- x0
for(i in 2:m){
prev_x <-  samples[i-1,]
new_x <- rmvnorm(1, prev_x, cov)
#print(t(prev_x))
alpha <- min(1, (f(c(new_x))*dmvnorm(new_x, prev_x, cov))/(f(c(prev_x))*dmvnorm(prev_x, new_x, cov)) )
u <- runif(1)
if (u<=alpha){
samples[i,]<-new_x
}
else{
samples[i,]<-prev_x
}
}
return (samples)
}
n <- 2
samples <- metropolis_hastings(p_scenario3, 10000, c(0.2, 0.5), diag(2), 2)
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
n <- 2
#samples <- rejection_sampling(p_scenario1, envelope_uniform, envelope_uniform_sampler, M, 1000, n)
samples <- metropolis_hastings(p_scenario1, 10000, c(0.2, 0.5), diag(2), 2)
#plot(samples)
#persp(den3d, box=FALSE)
den3d <- kde2d(samples[,1], samples[,2])
plot_ly(x=den3d$x, y=den3d$y, z=den3d$z) %>% add_surface()
